# Progress Log

PRD: abraxas-migration
Started: 2026-01-19

## Codebase Patterns

### Service Architecture
- Services use Effect.Service with static `layer` and `Live` properties (v4 compat)
- Config lives in internal Context.Tag, provided via Layer.provide
- All methods wrap with Effect.withSpan for observability
- Error handlers use type guards instead of type assertions to satisfy lint rules
- HTTP helpers use generic types to avoid `as` type assertions

---

## Task - setup-1

- Added @dnd-kit/core, @dnd-kit/sortable, @dnd-kit/utilities, date-fns dependencies
- Files changed: package.json, pnpm-lock.yaml
- **Learnings:** Type checking passes for new deps, old_repo contains reference code with expected errors

## Task - db-1

- Added six pgEnums to schema.ts: taskStatusEnum, taskExecutionStateEnum, taskTypeEnum, taskModelEnum, sessionStatusEnum, executionModeEnum
- Files changed: lib/services/db/schema.ts
- **Learnings:** Import pgEnum from drizzle-orm/pg-core, all enum declarations precede table definitions, snake_case for enum names in DB

## Task - db-2

- Added projects table with id, userId (FK), name, description, repositoryUrl, encryptedGithubToken, agentsMdContent, createdAt, updatedAt
- Foreign key to user.id with cascade delete
- Files changed: lib/services/db/schema.ts
- **Learnings:** Table follows standard pattern: cuid primary key, notNull constraints, cascade delete on FK, $onUpdate for updatedAt

## Task - db-3

- Added tasks table with id, projectId (FK), title, description, type (enum), model (enum), status (enum), executionState (enum), branchName, completedAt, createdAt, updatedAt
- Foreign key to projects.id with cascade delete
- Status defaults to 'abyss', executionState defaults to 'idle'
- Files changed: lib/services/db/schema.ts
- **Learnings:** Enum columns reference pgEnum definitions, default values set with .default(), nullable fields omit .notNull()

## Task - db-4

- Added comments table with id, taskId (FK), userId (nullable FK), isAgentComment (boolean), agentName (nullable), content, createdAt, updatedAt
- Foreign keys: tasks.id (cascade delete), user.id (cascade delete, nullable)
- isAgentComment defaults to false
- Files changed: lib/services/db/schema.ts
- **Learnings:** Nullable FKs omit .notNull(), both user and agent comments stored in same table with isAgentComment flag

## Task - db-5

- Added opencodeSessions table for tracking Sprites.dev execution lifecycle
- Columns: id, taskId (FK), sessionId, status (enum), executionMode (enum), spriteName, webhookSecret, branchName, pullRequestUrl, errorMessage, logs, messageCount, inputTokens, outputTokens, createdAt, updatedAt, completedAt
- Foreign key to tasks.id with cascade delete
- Status defaults to 'pending', all token/message/log fields are text (nullable)
- Files changed: lib/services/db/schema.ts
- **Learnings:** Session tracking table holds execution metadata, webhookSecret for HMAC verification, completedAt nullable for in-flight sessions

## Task - db-6

- Configured Drizzle relations for all new tables using RQB v2 defineRelations API
- Relations added: user->projects (many), projects->user (one), projects->tasks (many), tasks->project (one), tasks->comments (many), tasks->opencodeSessions (many), comments->task (one), comments->user (one, optional), opencodeSessions->task (one)
- Files changed: lib/services/db/schema.ts
- **Learnings:** defineRelations takes all tables in first arg, relations map in second; r.one/r.many methods with from/to fields; optional flag for nullable FKs

## Task - db-7

- Removed post table definition from schema.ts (lines 183-203)
- Removed post from defineRelations: removed from tables object, removed posts relation from user, removed entire post relation block
- Removed all post-related files: lib/core/post/, app/page.tsx, app/post-*.tsx, app/search-params.ts, app/api/example/route.ts
- Files changed: lib/services/db/schema.ts, deleted 10+ example files
- **Learnings:** Removing table requires cleanup of both table definition and all relations; example code must be removed to pass type checking

## Task - db-8

- Applied schema changes to database using pnpm db:push
- Migration was previously generated at lib/services/db/migrations/20260119093029_fancy_fenris/
- Verified all 4 new tables exist: projects, tasks, comments, opencodeSessions
- Files changed: database schema only (no code changes)
- **Learnings:** Project uses db:push not db:migrate; drizzle-kit push applies changes directly; local Postgres doesn't require SSL (unlike Neon)

## Task - service-2

- Created lib/services/sprites/errors.ts with four error types
- SpritesApiError: API failures with status/cause
- SpritesNotFoundError: 404 responses with spriteName
- SpritesConfigError: missing env vars
- SpriteExecutionError: command execution failures
- Files changed: lib/services/sprites/errors.ts
- **Learnings:** Error types defined before service implementation; all extend Data.TaggedError

## Task - service-1

- Created lib/services/sprites/live-layer.ts with Sprites Effect service
- Methods: createSprite, getSprite, destroySprite, execCommand, listSprites
- Internal SpritesConfig Context.Tag for SPRITES_TOKEN, WEBHOOK_BASE_URL, SPRITE_TIMEOUT_MS
- Used generic makeRequest<T> helper to avoid type assertions
- Added isErrorWithStatus type guard to handle fetch errors safely
- All methods annotate spans with relevant attributes
- Files changed: lib/services/sprites/live-layer.ts
- **Learnings:** Generic helper functions eliminate need for `as` assertions; type guards satisfy @typescript-eslint/consistent-type-assertions rule

## Task - service-3

- Imported Sprites service in lib/layers.ts
- Added Sprites.Live to Layer.mergeAll in AppLayer
- Files changed: lib/layers.ts
- **Learnings:** Services merge via Layer.mergeAll; use .Live to get fully composed layer with dependencies satisfied

## Task - security-1

- Created lib/core/crypto/errors.ts with EncryptionError, DecryptionError, CryptoConfigError
- Created lib/core/crypto/encrypt.ts with encryptToken/decryptToken functions
- Uses AES-256-GCM with random IV and salt per encryption
- Encoded format: iv:salt:authTag:encryptedData (base64)
- Files changed: lib/core/crypto/errors.ts, lib/core/crypto/encrypt.ts
- **Learnings:** Use Redacted.value() to access Config.redacted values; prefix unused vars with underscore to satisfy ESLint; Data.TaggedError sufficient for simple error types (no need for Schema.TaggedError)

## Task - domain-project-1

- Created lib/core/project/get-projects.ts for RSC data loading
- Returns Effect with array of projects filtered by current user's ID
- Uses getSession() to extract user, Db service to query schema.projects table
- Filters by eq(schema.projects.userId, user.id)
- Files changed: lib/core/project/get-projects.ts
- **Learnings:** Domain functions for read operations follow simple pattern: getSession → Db → query → return; no error handling needed beyond UnauthenticatedError from getSession

## Task - domain-project-2

- Created lib/core/project/get-project.ts for single project loading by ID
- Returns Effect with single project
- Verifies user owns project before returning
- Returns NotFoundError if project doesn't exist (length === 0 check on result array)
- Returns UnauthorizedError if userId doesn't match session user
- Files changed: lib/core/project/get-project.ts
- **Learnings:** Authorization checks: first check existence (NotFoundError), then check ownership (UnauthorizedError); Drizzle select returns array so must access [0] after length check

## Task - domain-project-3

- Created lib/core/project/create-project-action.ts server action
- 'use server' directive at top
- Accepts CreateProjectInput: name, description, repositoryUrl, githubToken, agentsMdContent
- Encrypts githubToken using encryptToken() before storage
- Uses NextEffect.runPromise with AppLayer and Effect.scoped
- matchEffect handles UnauthenticatedError (redirect to login) and generic errors
- Returns { _tag: 'Success', data: project } on success with revalidatePath('/')
- Has Effect.withSpan('action.project.create') with operation attribute
- Files changed: lib/core/project/create-project-action.ts
- **Learnings:** Server actions return typed error objects or success objects; revalidatePath called in onSuccess handler; encrypted tokens stored directly in projects table

## Task - domain-project-4

- Created lib/core/project/update-project-action.ts server action
- Accepts UpdateProjectInput with projectId and optional fields: name, description, repositoryUrl, githubToken, agentsMdContent
- Uses getProject() to verify ownership before update
- Re-encrypts githubToken if provided (only if field is in input)
- Builds partial update object conditionally (only includes fields present in input)
- matchEffect handles NotFoundError, UnauthorizedError, UnauthenticatedError separately
- Revalidates both '/' and '/rituals/[id]' paths on success
- Files changed: lib/core/project/update-project-action.ts
- **Learnings:** Update actions use getProject() for ownership check; partial updates built conditionally with !== undefined checks; revalidate all affected paths

## Task - domain-project-5

- Created lib/core/project/delete-project-action.ts server action
- 'use server' directive at top
- Accepts projectId string parameter
- Uses getProject() to verify ownership before delete
- Performs db.delete() with cascade (automatically deletes tasks, comments, sessions via FK constraints)
- matchEffect handles NotFoundError, UnauthorizedError, UnauthenticatedError
- Revalidates '/' path on success (no need to revalidate detail page since it no longer exists)
- Files changed: lib/core/project/delete-project-action.ts
- **Learnings:** Delete actions simpler than update - no partial data handling; cascade delete via FK means no manual cleanup of child records needed

## Task - domain-task-1

- Created lib/core/task/get-tasks.ts for RSC data loading
- Accepts projectId parameter
- Verifies user owns project before returning tasks (checks project exists, then checks userId matches)
- Returns Effect with array of tasks filtered by projectId
- Has Effect.withSpan('Task.getTasks') for observability
- Files changed: lib/core/task/get-tasks.ts
- **Learnings:** Task read operations follow project pattern - verify ownership via parent project first, then fetch child resources

## Task - domain-task-2

- Created lib/core/task/create-task-action.ts server action
- 'use server' directive at top
- Accepts CreateTaskInput: projectId, title, description, type, model
- Uses getProject() to verify ownership before creation
- Creates task with status='abyss' and executionState='idle' (schema defaults)
- matchEffect handles NotFoundError, UnauthorizedError, UnauthenticatedError separately
- Revalidates /rituals/[projectId] path on success
- Files changed: lib/core/task/create-task-action.ts
- **Learnings:** Task creation actions use getProject() for ownership check; schema defaults handle status/state without explicit values in insert; revalidate the board page to show new task

## Task - domain-task-3

- Created lib/core/task/update-task-action.ts server action
- Accepts UpdateTaskInput with taskId and optional fields: status, type, model, executionState, branchName
- Verifies ownership via two-step check: fetch task → fetch parent project → verify userId matches
- Builds partial update object conditionally (only includes fields present in input)
- matchEffect handles NotFoundError (task or project), UnauthorizedError, UnauthenticatedError
- Returns both task and projectId in success result to enable revalidatePath
- Revalidates /rituals/[projectId] path on success
- Files changed: lib/core/task/update-task-action.ts
- **Learnings:** Task update requires two fetches (task for projectId, project for ownership); return projectId alongside updated entity when revalidation path needs it; partial updates use !== undefined checks

## Task - domain-task-4

- Created lib/core/task/delete-task-action.ts server action
- 'use server' directive at top
- Accepts taskId string parameter
- Verifies ownership via two-step check: fetch task for projectId → fetch parent project → verify userId matches
- Performs db.delete() with cascade (automatically deletes comments and sessions via FK constraints)
- matchEffect handles NotFoundError (task or project), UnauthorizedError, UnauthenticatedError
- Returns both taskId and projectId in success result to enable revalidatePath
- Revalidates /rituals/[projectId] path on success
- Files changed: lib/core/task/delete-task-action.ts
- **Learnings:** Task delete follows same ownership verification pattern as update (two fetches); cascade delete via FK means no manual cleanup of child records; return projectId for revalidation path construction
## Task - domain-task-5

- Created lib/core/task/execute-task-action.ts server action for Sprites.dev execution
- Created lib/core/sprites/callback-script.ts with webhook callback script generation
- Created lib/core/sprites/spawn-sprite.ts with spawnSpriteForTask Effect function
- 'use server' directive at top of action
- Accepts taskId, verifies ownership via getProject()
- Checks task not already in_progress (ValidationError if executing)
- Fetches all comments for task, builds prompt from task title + description + comments
- Decrypts GitHub token using decryptToken()
- Spawns sprite via spawnSpriteForTask helper
- Creates opencodeSessions record with pending status, sprite mode, webhookSecret
- Updates task to status='ritual', executionState='in_progress', sets branchName
- Posts agent comment with execution details (sprite name, branch)
- matchEffect handles UnauthenticatedError (redirect), NotFoundError, UnauthorizedError, ValidationError
- Revalidates /rituals/[projectId] path on success
- Files changed: lib/core/task/execute-task-action.ts, lib/core/sprites/callback-script.ts, lib/core/sprites/spawn-sprite.ts
- **Learnings:** Complex orchestration requires helper functions (callback script, spawn sprite); decryption happens in action before passing to Effect pipeline; sprite execution is fire-and-forget (webhook handles completion); agent comments use isAgentComment=true with agentName field; execution state transitions: idle → in_progress; status transitions: abyss/altar → ritual

## Task - domain-comment-1

- Created lib/core/comment/get-comments.ts for RSC data loading
- Returns Effect with array of comments for a task
- Verifies user owns parent project before returning comments (two-step fetch: task → project → ownership check)
- Orders comments by createdAt ascending using asc() helper
- Has Effect.withSpan('Comment.getComments') for observability
- Files changed: lib/core/comment/get-comments.ts
- **Learnings:** Comment read operations follow task pattern - verify ownership via parent project (task → project); use asc() from drizzle-orm for ascending order in orderBy()

## Task - domain-comment-2

- Created lib/core/comment/create-comment-action.ts server action
- 'use server' directive at top
- Accepts CreateCommentInput with taskId and content
- Verifies ownership via two-step check: fetch task for projectId → fetch parent project → verify userId matches
- Creates comment with userId from session, isAgentComment=false, no agentName
- matchEffect handles UnauthenticatedError (redirect), NotFoundError (task or project), UnauthorizedError
- Returns both comment and projectId in success result to enable revalidatePath
- Revalidates /rituals/[projectId] path on success
- Files changed: lib/core/comment/create-comment-action.ts
- **Learnings:** Comment creation follows same ownership verification pattern as task actions (two fetches); return projectId for revalidation path construction; user comments automatically get userId from session

## Task - domain-comment-3

- Created lib/core/comment/create-agent-comment.ts internal function
- NOT a server action - pure Effect function for internal use
- Returns Effect that creates comment with isAgentComment=true, userId=null
- Accepts CreateAgentCommentInput: taskId, content, agentName
- No ownership verification needed - called from contexts that already verified access
- Has Effect.withSpan('Comment.createAgentComment') with operation attribute
- Returns created comment from .returning()
- Files changed: lib/core/comment/create-agent-comment.ts
- **Learnings:** Internal domain functions skip ownership checks (caller's responsibility); agent comments set userId=null with agentName field; reusable across webhook handlers and server actions

## Task - domain-session-1

- Created lib/core/session/create-session.ts for creating opencode sessions
- Created lib/core/session/update-session.ts for updating session status and stats
- Created lib/core/session/get-latest-session.ts for fetching most recent session by taskId
- All functions return Effect with appropriate types (OpencodeSession or NotFoundError)
- update-session builds partial update object conditionally (only includes fields present in input)
- get-latest-session orders by createdAt desc with limit 1, returns NotFoundError if no sessions
- All have Effect.withSpan annotations for observability
- Files changed: lib/core/session/create-session.ts, lib/core/session/update-session.ts, lib/core/session/get-latest-session.ts
- **Learnings:** Session management follows same patterns as comment/task - Effect.gen with Db service, annotateCurrentSpan for tracing, conditional field updates with !== undefined checks; get functions use desc() ordering for latest-first; session stats (messageCount, tokens) stored as text fields per schema

## Task - api-1

- Created app/api/webhooks/sprite/[taskId]/route.ts webhook handler API route
- POST handler extracts taskId from dynamic route params (using Promise-based context.params)
- Reads raw body as text using request.text() for signature verification
- Gets X-Webhook-Signature header and validates presence
- Fetches latest session to get webhookSecret using getLatestSession(taskId)
- Verifies HMAC-SHA256 signature using crypto.createHmac and timingSafeEqual
- Checks buffer lengths match before timing-safe comparison (prevents timing attacks)
- Returns 401 for missing/invalid signatures, 500 for missing webhook secret
- Parses body using Schema.decodeUnknownEither (no type assertions)
- Returns 400 for invalid payload format
- Uses Effect.runPromise with AppLayer and Effect.scoped
- Has Effect.withSpan('webhook.sprite') with operation attribute
- Files changed: app/api/webhooks/sprite/[taskId]/route.ts
- **Learnings:** Next.js 15 route params are async (Promise<{ taskId: string }>); use type import for NextRequest to satisfy lint; use Schema.decodeUnknownEither instead of type assertions for JSON parsing; HMAC verification requires timing-safe comparison via crypto.timingSafeEqual; raw body must be preserved for signature verification before parsing

## Task - api-2

- Implemented webhook payload type handlers for all 5 event types: started, progress, completed, error, question
- Created 5 Schema.Struct definitions for each payload type using Schema.Literal for discriminated union
- handleStarted: updates session to in_progress, posts agent comment with fire emoji
- handleProgress: updates session stats (messageCount, inputTokens, outputTokens as strings)
- handleCompleted: updates session to completed with completedAt/pullRequestUrl, moves task to 'trial' status with executionState 'awaiting_review', posts success comment, destroys sprite with error suppression
- handleError: updates session to error with errorMessage/completedAt, moves task to 'cursed' status with executionState 'error', posts error comment, destroys sprite with error suppression
- handleQuestion: posts agent comment with question mark emoji (no session/task updates)
- All handlers use internal Effect functions (updateSession, createAgentComment) not server actions
- Task status updates use direct db.update() with eq() filter (no ownership verification needed in webhook context)
- Sprite destruction wrapped in Effect.catchAll to log warnings but not fail webhook on cleanup errors
- Used if/else discriminator instead of Match.tag (Schema.Literal doesn't create proper tagged union for Match)
- Files changed: app/api/webhooks/sprite/[taskId]/route.ts
- **Learnings:** Webhook handlers use internal Effect functions not server actions (no user context); sprite cleanup failures should not fail webhook processing (use catchAll + logWarning); Schema.Union with Schema.Literal creates type discriminator but not Effect tagged union (use if/else not Match.tag); task/session updates in webhooks skip ownership checks (verified during execution start)

## Task - context-1

- Created lib/contexts/fire-intensity-context.tsx with FireIntensityProvider component
- Tracks running tasks with id, startedAt, messageCount fields
- Exports useFireIntensity hook that throws error if used outside provider
- Provides addRunningTask, removeRunningTask, updateTaskMessages functions
- calculateIntensity: base 10 per task + message bonus (capped at 10) + time bonus (1 per 30s, capped at 15)
- Recalculates intensity every second via setInterval in useEffect
- Files changed: lib/contexts/fire-intensity-context.tsx
- **Learnings:** Context pattern for global UI state; intensity formula allows exceeding 35 for color shift logic; time bonus increments automatically via interval without external updates

## Task - component-1

- Created components/ascii-fire.tsx with ASCII fire animation
- Uses requestAnimationFrame for smooth 60fps animation loop
- Fire height caps at intensity 35, above 35 color shifts from white to red/yellow
- Smoothly interpolates intensity changes via targetIntensityRef and currentIntensityRef
- Renders pre element fixed at bottom of screen with pointer-events-none
- Fire propagates upwards with decay and horizontal drift for realistic effect
- ASCII characters sorted by visual density: ' .:-=+*#%@'
- Responds to window resize events
- Files changed: components/ascii-fire.tsx
- **Learnings:** Animation state stored in refs to avoid triggering re-renders; intensity interpolation creates smooth visual transitions; cleanup function cancels animation frame and removes event listeners

## Task - component-2

- Created components/fire-background.tsx as wrapper component
- 'use client' directive for React hook usage
- Imports useFireIntensity hook from context to get dynamic intensity value
- Renders AsciiFire component with intensity prop from context
- Files changed: components/fire-background.tsx
- **Learnings:** Simple wrapper pattern connects context provider to presentational component; keeps AsciiFire reusable with prop-based intensity

## Task - component-3

- Created components/rituals/create-ritual-dialog.tsx with form for project creation
- 'use client' directive with React hooks for form state and loading/error handling
- Form fields: name, description, repositoryUrl, githubToken, agentsMdContent
- Calls createProjectAction on submit with proper error handling
- Shows loading state during submission ('Summoning...')
- Shows error message in styled error box on failure
- Redirects to /rituals/[id] on success using router.push + router.refresh
- Uses Dialog, Input, Textarea, Button, Label from shadcn/ui
- Files changed: components/rituals/create-ritual-dialog.tsx
- **Learnings:** Form uses controlled inputs with useState for form data; conditional values use undefined instead of empty strings; error display uses themed styling with destructive colors; router.refresh() ensures server components refetch data after navigation

## Task - component-4

- Created components/invocations/create-invocation-dialog.tsx with form for task creation
- 'use client' directive with React hooks for form state and loading/error handling
- Form fields: title, description, type (select), model (select)
- Accepts ritualId prop, calls createTaskAction on submit
- Type options: bug, feature, plan, other via Select dropdown
- Model options: grok-1, claude-sonnet-4-5, claude-opus-4-5, claude-haiku-4-5 via Select dropdown
- Shows loading state during submission ('Invoking...')
- Shows error message in styled error box on failure
- Uses Dialog, Input, Textarea, Select, Button, Label from shadcn/ui
- Type-safe select handlers using type guard functions (isTaskType, isTaskModel) instead of type assertions
- Files changed: components/invocations/create-invocation-dialog.tsx
- **Learnings:** Avoid type assertions in Select handlers by using type guard functions with explicit equality checks; null-check Select onValueChange value before type guard; explicit type guards with OR conditions satisfy ESLint no-type-assertion rule

## Task - component-5

- Created components/invocations/comment.tsx with display component for user and agent comments
- User comments: left-aligned with purple accent (bg-purple-950/30 border-purple-500/20, text-purple-400)
- Agent comments: right-aligned with cyan accent (bg-cyan-950/30 border-cyan-500/20, text-cyan-400)
- Shows relative timestamp using formatDistanceToNow from date-fns
- Whitespace preserved with whitespace-pre-wrap class for markdown content
- DisplayName defaults to 'Abraxas' for agents, 'User' for users if names missing
- Files changed: components/invocations/comment.tsx
- **Learnings:** Presentational component with no client interactivity (no 'use client' needed); color theming via conditional className strings; date-fns formatDistanceToNow provides human-readable relative times

## Task - component-6

- Created components/invocations/add-comment-form.tsx with textarea and submit button
- 'use client' directive for React hooks
- Accepts onSubmit callback prop that returns Promise<void>
- Textarea with 3 rows, disabled during loading, placeholder text
- Submit button disabled when loading or content is empty (trimmed)
- Clears form content on successful submit
- Error handling delegated to parent component (onSubmit caller)
- Loading state shows 'Posting...' text
- Files changed: components/invocations/add-comment-form.tsx
- **Learnings:** Simple form component pattern - controlled input with useState, async onSubmit handler, clear form on success; error handling responsibility belongs to parent; disabled state on button prevents empty submissions

## Task - component-7

- Created components/invocations/task-detail-modal.tsx with full task detail view
- 'use client' directive with React hooks for state management
- Accepts task, comments, ritualId, repositoryUrl, session, open, onOpenChange, onUpdate props
- Shows task metadata: title, description, status, type, model, executionState
- Branch link to GitHub compare view if branchName exists
- Session stats display: messageCount and total tokens (parsed from string fields)
- Comments list with Comment component, synced with initialComments prop
- AddCommentForm integration with createCommentAction
- Type-safe Select handlers for type, model, executionState using type guard functions
- Update handlers call updateTaskAction and handle optimistic UI + error states
- Delete button with nested confirmation dialog, calls deleteTaskAction
- Error display component for action failures
- Uses Dialog, Select, Button from shadcn/ui
- Files changed: components/invocations/task-detail-modal.tsx
- **Learnings:** Modal uses server actions not API routes; type guards with null check for Select onValueChange (accepts string | null); session stats stored as text, must parse to int; nested Dialog for confirmation works (delete confirm inside detail modal); optimistic UI updates for comments by adding to local state; unused props prefixed with underscore

## Task - page-1

- Created app/(dashboard)/page.tsx with RSC Suspense+Content pattern
- Created app/(dashboard)/layout.tsx as simple wrapper
- Content fetches projects via getProjects() Effect function
- Header with title, CreateRitualDialog button, sign-out form button
- Empty state when no projects with centered call-to-action
- Project grid with Link-wrapped Card components showing name, description, repo, date
- Logout uses form POST to /api/auth/sign-out (better-auth endpoint)
- Type-safe error handling with 'message' in error type guard instead of assertion
- Uses Effect.matchEffect with UnauthenticatedError redirect to /login
- export const dynamic = 'force-dynamic' at top of file
- Files changed: app/(dashboard)/page.tsx, app/(dashboard)/layout.tsx
- **Learnings:** RSC pages use Link for navigation not router.push; sign-out via form POST to better-auth endpoint not client-side authClient.signOut(); type guards with 'in' operator satisfy no-type-assertion rule; await cookies() first line of Content component ensures dynamic rendering

## Task - page-2

- Created app/(dashboard)/rituals/[id]/page.tsx with RSC Suspense+Content pattern fetching project and tasks
- Created board-client.tsx as "use client" component handling drag-and-drop with @dnd-kit
- Six column kanban board: abyss, altar, ritual (double height), trial, cursed (stacked), vanquished (double height)
- DndContext with PointerSensor (8px activation distance)
- DroppableColumn and DraggableCard components with visual state based on executionState
- Drag to ritual column triggers executeTaskAction server action
- Optimistic UI updates with type-safe status guards (no `as` assertions)
- Polling every 10s for running tasks via router.refresh() pattern
- localStorage persistence for running tasks across page refreshes
- Fire intensity context integration with message count tracking
- Type guards for TaskStatus validation instead of assertions
- Back button navigates to dashboard, placeholder button for create invocation
- Files changed: app/(dashboard)/rituals/[id]/page.tsx, app/(dashboard)/rituals/[id]/board-client.tsx
- **Learnings:** RSC can pass data to client components for DnD; type guards `(value: string): value is Type` satisfy no-type-assertion lint rule; router.refresh() triggers RSC re-fetch; DndContext active.id and over.id are string|number so need type checks; localStorage operations need typeof window check; Effect.runPromise works in RSC pages but NextEffect.runPromise for redirects

## Task - page-3

- Integrated FireIntensityProvider and FireBackground into app/layout.tsx
- FireIntensityProvider wraps all page content including NuqsAdapter, Toaster, and children
- FireBackground rendered as sibling to other layout components inside provider
- Fire animation now appears at bottom of all pages via global layout
- Files changed: app/layout.tsx
- **Learnings:** Provider order matters - FireIntensityProvider must wrap FireBackground consumer; layout.tsx is best place for global UI features like fire animation; FireBackground placed after Toaster ensures fire appears on top visually
